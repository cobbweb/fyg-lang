FliteScript {
  Entrypoint = Script
  
  // Whitespace handling
  space := whitespace | terminator | comment
  terminator = "\n" | "\r" | "\u2028" | "\u2029"
  eol = 
    | space* (terminator | end | &"}") -- one
    | ~terminator space* (terminator | ~multiLineCommentNoNL multiLineComment) -- two

  multiLineCommentNoNL = "/*" (~("*/" | terminator) any)* "*/"

  whitespace = "\t"
             | "\x0B"    -- verticalTab
             | "\x0C"    -- formFeed
             | " "
             | "\u00A0"  -- noBreakSpace
             | "\uFEFF"  -- byteOrderMark
             | unicodeSpaceSeparator
  Script = ScriptBody?
  
  ScriptBody = StatementList
    
  StatementList = StatementListItem+

  StatementListItem =
    | Statement
    | StatementListItem eol Declaration-- declaration
    | Declaration     

  Statement = 
    | Block
    | EmptyStatement
    | ExpressionStatement
    
  Block = 
    | "{" StatementList "}" -- body
    
  ConciseBody =
    | ~"{" Expression         -- expression
    | "{" StatementList? "}"  -- block
    
  ExpressionStatement = ~("{") Expression 

  EmptyStatement = terminator
        
  Expression =
    | ArrowFunctionExpression                               -- function
    | LeftHandSideExpression "=" Expression                 -- nested
    | LeftHandSideExpression AssignmentOperator Expression  -- operation
    | IfElseExpression                                      -- ifElse
    | AwaitExpression
    | ExpressionTree
    | CallExpression
    | PrimaryExpression
  
  Declaration =
    | ConstDeclaration
    | TypeDeclaration

  ConstDeclaration = const identifier TypeAnnotation? "=" Expression #eol
  
  TypeDeclaration = type customTypeName GenericDeclaration? "=" TypeAssignmentExpression
  
  ArrowFunctionExpression =
    | async ~async ArrowFunctionExpression                                    -- async
    | "(" ListOf<Param, ","> ")" TypeAnnotation? "=>" ConciseBody -- multiParam
    | Param "=>" ConciseBody                                                  -- oneParam
  
  Param = "..."? identifier TypeAnnotation?

  IfElseExpression =
    | if "(" ExpressionTree ")" Statement else Statement -- if

  CallExpression =
    | CallExpression Arguments                -- function
    | CallExpression "[" CallExpression "]"   -- indexNotation
    | CallExpression "." identifier           -- dotNotation
    | CallExpression TemplateLiteral          -- taggedLiteral
    | identifier
    
    AwaitExpression = await ~await Expression

  LeftHandSideExpression =
    | CallExpression
    | MemberExpression
  
  ExpressionTree = CoalesceExpression

  CoalesceExpression =
    | LogicalORExpression "??" LogicalORExpression -- coalesce
    | LogicalORExpression

  LogicalORExpression =
    | LogicalORExpression "||" LogicalANDExpression -- lor
    | LogicalANDExpression
    
  LogicalANDExpression =
    | LogicalANDExpression "&&" BitwiseORExpression -- land
    | BitwiseORExpression

  BitwiseORExpression =
    | BitwiseORExpression "|" BitwiseXORExpression -- bor
    | BitwiseXORExpression

  BitwiseXORExpression =
    | BitwiseXORExpression "^" BitwiseANDExpression -- bxor
    | BitwiseANDExpression

  BitwiseANDExpression =
    | BitwiseANDExpression "&" EqualityExpression -- band
    | EqualityExpression

  EqualityExpression =
    | EqualityExpression "==" RelationalExpression  -- equal
    | EqualityExpression "!=" RelationalExpression  -- notEqual
    | RelationalExpression

  RelationalExpression =
    | RelationalExpression "<" ShiftExpression         -- lt
    | RelationalExpression ">" ShiftExpression         -- gt
    | RelationalExpression "<=" ShiftExpression        -- le
    | RelationalExpression ">=" ShiftExpression        -- ge
    | RelationalExpression instanceof ShiftExpression  -- instanceOfExp
    | ShiftExpression

  ShiftExpression = 
    | ShiftExpression "<<" AdditiveExpression  -- lsl
    | ShiftExpression ">>>" AdditiveExpression -- lsr
    | ShiftExpression ">>" AdditiveExpression  -- asr
    | AdditiveExpression

  AdditiveExpression = 
    | AdditiveExpression "+" MultiplicativeExpression -- add
    | AdditiveExpression "-" MultiplicativeExpression -- sub
    | MultiplicativeExpression

  MultiplicativeExpression = 
    | MultiplicativeExpression "*" ExponentiationExpression -- mul
    | MultiplicativeExpression "/" ExponentiationExpression -- div
    | MultiplicativeExpression "%" ExponentiationExpression -- mod
    | ExponentiationExpression

  ExponentiationExpression =
    | ExponentiationExpression "**" UnaryExpression -- exponent
    | UnaryExpression
  
  UnaryExpression = 
    | typeof UnaryExpression  -- typeofExp
    | "-"    UnaryExpression  -- negative
    | "+"    UnaryExpression  -- positive
    | "~"    UnaryExpression  -- bnot
    | "!"    UnaryExpression  -- lnot
    | LeftHandSideExpression
    
  MemberExpression =
    | MemberExpression "[" Expression "]"       -- indexNotation
    | MemberExpression "." identifierName       -- dotNotation
    | PrimaryExpression
    
  AssignmentOperator = ">>>=" | "<<=" | ">>=" | "**=" | "*=" | "/=" | "%=" | "+=" | "-=" | "&=" | "^=" | "|="  

  PrimaryExpression =
    | literal
    | ArrayLiteral
    | ObjectLiteral
    | regularExpressionLiteral
    | TemplateLiteral
    | "(" Expression ")" -- wrappedWithParens
             
  TypeExpression = 
    | typeof TypeExpressionPart                       -- typeof
    | "{" ListOf<TypePropertyDefinition, ","> "," "}" -- inlineType
    | "[" TypeExpression "]"                          -- tuple
    | TypeExpressionPart "<" NonemptyListOf<TypeExpression, ","> ">"       -- generic
    | TypeExpressionPart "[]"                         -- array
    | TypeExpressionPart
                 
  TypeExpressionPart = 
    | ListOf<identifier, ".">                       
    | nativeTypes 
    
  TypePropertyDefinition =
    | identifier ":" TypeExpression
                 
  Arguments = "(" ListOf<Expression, ","> ")"
             
  TemplateLiteral = 
    | noSubstitutionTemplate
    | templateHead Expression TemplateSpans  -- xxx
                  
  ArrayLiteral = 
    | "[" terminator* NonemptyListOf<ArrayValueExpression, ","> "," terminator* "]"   -- nonEmpty
    | "[" "]"                                                 -- empty
    
  ArrayValueExpression =
    | Expression
    | SpreadElement
    
  SpreadElement = "..." Expression
  
  ObjectLiteral = 
    | "{" NonemptyListOf<PropertyDefinition, ","> "," "}" -- nonEmpty
    | "{" "}"                                                 -- empty
    
  PropertyDefinition =
    | "..." Expression                  -- spread
    | PropertyName ":" Expression       -- standard
    | identifierName                              -- shorthand
  
  PropertyName = 
    | "[" Expression "]"    -- computed
    | identifierName
    | stringLiteral
    | numericLiteral
    
  TemplateSpans = TemplateMiddleList* templateTail

  TemplateMiddleList = templateMiddle* Expression
  
  TypeAnnotation = ":" TypeExpression
  
  TypeAssignmentExpression =
    | TypeAssignmentExpression "[]" -- arrayShorthand
    | ObjectType
    | VariantType
    | TupleType
    | nativeTypes

  VariantType =
    | NonemptyListOf<VariantIdenitier, "|">
    
  TupleType =
    | "[" ListOf<TypeExpression, ","> "]"
    
  VariantIdenitier =
    | customTypeName "(" customTypeName ")" -- generic
    | customTypeName
  
  TypeDeclarationName =
    | identifier GenericDeclaration?
    
  GenericDeclaration =
    | "<" NonemptyListOf<GenericName, ","> ">" 
    
  GenericName = TypeDeclarationName | customTypeName

  ObjectType =
    | "{" ListOf<PropertyTypeDefinition, ","> "," "}"
    
  PropertyTypeDefinition =
    | identifierName ":" TypeExpression

  comment = multiLineComment | singleLineComment
  multiLineComment = "/*" (~"*/" any)* "*/"
  singleLineComment = "//" (~terminator any)*

  identifier (an identifier) = ~reservedWord identifierName
  identifierName = identifierStart identifierPart*

  identifierStart = letter | "$" | "_"
                  | "\\" unicodeEscapeSequence -- escaped
  identifierPart = identifierStart | unicodeCombiningMark
                 | unicodeDigit | unicodeConnectorPunctuation
                 | "\u200C" | "\u200D"
  customTypeName = upper alnum*
  letter += unicodeCategoryNl
  unicodeCategoryNl
    = "\u2160".."\u2182" | "\u3007" | "\u3021".."\u3029"
  unicodeDigit (a digit)
    = "\u0030".."\u0039" | "\u0660".."\u0669" | "\u06F0".."\u06F9" | "\u0966".."\u096F" | "\u09E6".."\u09EF" | "\u0A66".."\u0A6F" | "\u0AE6".."\u0AEF" | "\u0B66".."\u0B6F" | "\u0BE7".."\u0BEF" | "\u0C66".."\u0C6F" | "\u0CE6".."\u0CEF" | "\u0D66".."\u0D6F" | "\u0E50".."\u0E59" | "\u0ED0".."\u0ED9" | "\u0F20".."\u0F29" | "\uFF10".."\uFF19"

  unicodeCombiningMark (a Unicode combining mark)
    = "\u0300".."\u0345" | "\u0360".."\u0361" | "\u0483".."\u0486" | "\u0591".."\u05A1" | "\u05A3".."\u05B9" | "\u05BB".."\u05BD" | "\u05BF".."\u05BF" | "\u05C1".."\u05C2" | "\u05C4".."\u05C4" | "\u064B".."\u0652" | "\u0670".."\u0670" | "\u06D6".."\u06DC" | "\u06DF".."\u06E4" | "\u06E7".."\u06E8" | "\u06EA".."\u06ED" | "\u0901".."\u0902" | "\u093C".."\u093C" | "\u0941".."\u0948" | "\u094D".."\u094D" | "\u0951".."\u0954" | "\u0962".."\u0963" | "\u0981".."\u0981" | "\u09BC".."\u09BC" | "\u09C1".."\u09C4" | "\u09CD".."\u09CD" | "\u09E2".."\u09E3" | "\u0A02".."\u0A02" | "\u0A3C".."\u0A3C" | "\u0A41".."\u0A42" | "\u0A47".."\u0A48" | "\u0A4B".."\u0A4D" | "\u0A70".."\u0A71" | "\u0A81".."\u0A82" | "\u0ABC".."\u0ABC" | "\u0AC1".."\u0AC5" | "\u0AC7".."\u0AC8" | "\u0ACD".."\u0ACD" | "\u0B01".."\u0B01" | "\u0B3C".."\u0B3C" | "\u0B3F".."\u0B3F" | "\u0B41".."\u0B43" | "\u0B4D".."\u0B4D" | "\u0B56".."\u0B56" | "\u0B82".."\u0B82" | "\u0BC0".."\u0BC0" | "\u0BCD".."\u0BCD" | "\u0C3E".."\u0C40" | "\u0C46".."\u0C48" | "\u0C4A".."\u0C4D" | "\u0C55".."\u0C56" | "\u0CBF".."\u0CBF" | "\u0CC6".."\u0CC6" | "\u0CCC".."\u0CCD" | "\u0D41".."\u0D43" | "\u0D4D".."\u0D4D" | "\u0E31".."\u0E31" | "\u0E34".."\u0E3A" | "\u0E47".."\u0E4E" | "\u0EB1".."\u0EB1" | "\u0EB4".."\u0EB9" | "\u0EBB".."\u0EBC" | "\u0EC8".."\u0ECD" | "\u0F18".."\u0F19" | "\u0F35".."\u0F35" | "\u0F37".."\u0F37" | "\u0F39".."\u0F39" | "\u0F71".."\u0F7E" | "\u0F80".."\u0F84" | "\u0F86".."\u0F87" | "\u0F90".."\u0F95" | "\u0F97".."\u0F97" | "\u0F99".."\u0FAD" | "\u0FB1".."\u0FB7" | "\u0FB9".."\u0FB9" | "\u20D0".."\u20DC" | "\u20E1".."\u20E1" | "\u302A".."\u302F" | "\u3099".."\u309A" | "\uFB1E".."\uFB1E" | "\uFE20".."\uFE23"

  unicodeConnectorPunctuation = "\u005F" | "\u203F".."\u2040" | "\u30FB" | "\uFE33".."\uFE34" | "\uFE4D".."\uFE4F" | "\uFF3F" | "\uFF65"
  unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"
  
  nativeTypes = "string" | "number" | "boolean" | "void" | "array" | "object"

  reservedWord = keyword | futureReservedWord | booleanLiteral

  // Note: keywords that are the complete prefix of another keyword should
  // be prioritized (e.g. 'in' should come before 'instanceof')
  keyword = if       | else      | import     | from
          | type     | as        | enum       | typeof
          | void     | match     | case       | debugger
          | default  | panic     | instanceof | const
          | module   | when      | async      | await     | open

  futureReservedWord = class  | new   | extends
                     | super  | let   | export   | readonly
                     | async  | await | do       | implements

  literal = booleanLiteral | numericLiteral
          | stringLiteral | regularExpressionLiteral // spec forgot Regexp literals in appendix?

  booleanLiteral = ("true" | "false") ~identifierPart

  // For semantics on how decimal literals are constructed, see section 7.8.3

  // Note that the ordering of hexIntegerLiteral and decimalLiteral is reversed w.r.t. the spec
  // This is intentional: the order decimalLiteral | hexIntegerLiteral will parse
  // "0x..." as a decimal literal "0" followed by "x..."
  numericLiteral = octalIntegerLiteral | hexIntegerLiteral | decimalLiteral

  decimalLiteral = 
    | decimalIntegerLiteral "." decimalDigit* exponentPart -- bothParts
    |                       "." decimalDigit+ exponentPart -- decimalsOnly
    | decimalIntegerLiteral                   exponentPart -- integerOnly

  decimalIntegerLiteral = nonZeroDigit decimalDigit*  -- nonZero
                        | "0"                         -- zero
  decimalDigit = "0".."9" | "_"
  nonZeroDigit = "1".."9"

  exponentPart = 
    | exponentIndicator signedInteger -- present
    |                                 -- absent
  exponentIndicator = "e" | "E"
  signedInteger = 
    | "+" decimalDigit* -- positive
    | "-" decimalDigit* -- negative
    |     decimalDigit+ -- noSign

  hexIntegerLiteral = 
    | "0x" hexDigit+
    | "0X" hexDigit+

  // hexDigit defined in Ohm's built-in rules (otherwise: hexDigit = "0".."9" | "a".."f" | "A".."F")

  octalIntegerLiteral = "0" octalDigit+

  octalDigit = "0".."7"

  // For semantics on how string literals are constructed, see section 7.8.4
  stringLiteral = "'" singleStringCharacter* "'"
  singleStringCharacter = 
    | ~("'" | "\\" | terminator) any   -- nonEscaped
    | "\\" escapeSequence       -- escaped
  template = noSubstitutionTemplate | templateHead
  noSubstitutionTemplate = "`" templateCharacter* "`"
  templateHead = "`" templateCharacter* "${"
  templateSubstitutionTail = templateMiddle | templateTail // Not used currently.
  templateMiddle = "}" templateCharacter* "${"
  templateTail = "}" templateCharacter* "`"
  templateCharacter =
    | "$" ~"{"
    | "\\" escapeSequence  -- escaped
    | ~("`" | "\\" | "$") any

  escapeSequence = 
    | unicodeEscapeSequence
    | hexEscapeSequence
    | octalEscapeSequence
    | characterEscapeSequence  // Must come last.
  characterEscapeSequence = 
    | singleEscapeCharacter
    | nonEscapeCharacter
  singleEscapeCharacter = "'" | "\"" | "\\" | "b" | "f" | "n" | "r" | "t" | "v"
  nonEscapeCharacter = ~(escapeCharacter | terminator) any 
  escapeCharacter = singleEscapeCharacter | decimalDigit | "x" | "u"
  octalEscapeSequence = 
    | zeroToThree octalDigit octalDigit    -- whole
    | fourToSeven octalDigit               -- eightTimesfourToSeven
    | zeroToThree octalDigit ~decimalDigit -- eightTimesZeroToThree
    | octalDigit ~decimalDigit             -- octal
  hexEscapeSequence = "x" hexDigit hexDigit
  unicodeEscapeSequence = "u" hexDigit hexDigit hexDigit hexDigit

  zeroToThree = "0".."3"
  fourToSeven = "4".."7"

  // ยง7.8.5 Regular Expression Literals -- https://es5.github.io/#x7.8.5

  regularExpressionLiteral = "/" regularExpressionBody "/" regularExpressionFlags
  regularExpressionBody = regularExpressionFirstChar regularExpressionChar*
  regularExpressionFirstChar = 
    | ~("*" | "\\" | "/" | "[") regularExpressionNonTerminator
    | regularExpressionBackslashSequence
    | regularExpressionClass
  regularExpressionChar = 
    | ~("\\" | "/" | "[") regularExpressionNonTerminator
    | regularExpressionBackslashSequence
    | regularExpressionClass
  regularExpressionBackslashSequence = "\\" regularExpressionNonTerminator
  regularExpressionNonTerminator = ~(terminator) any
  regularExpressionClass = "[" regularExpressionClassChar* "]"
  regularExpressionClassChar = 
    | ~("]" | "\\") regularExpressionNonTerminator
    | regularExpressionBackslashSequence
  regularExpressionFlags = identifierPart*

 // keywords
  if = "if" ~identifierPart
  else = "else" ~identifierPart
  do = "do" ~identifierPart
  import = "import" ~identifierPart
  from = "from" ~identifierPart
  type = "type" ~identifierPart
  as = "as" ~identifierPart
  enum = "enum" ~identifierPart
  typeof = "typeof" ~identifierPart
  void = "void" ~identifierPart
  match = "match" ~identifierPart
  case = "case" ~identifierPart
  debugger = "debugger" ~identifierPart
  default = "default" ~identifierPart
  panic = "panic" ~identifierPart
  instanceof = "instanceof" ~identifierPart
  module = "module" ~identifierPart
  when = "when" ~identifierPart
  async = "async" ~identifierPart
  await = "await" ~identifierPart
  open = "open" ~identifierPart
  const = "const" ~identifierPart

  // reserved keywords
  class = "class" ~identifierPart
  extends = "extends" ~identifierPart
  super = "super" ~identifierPart
  let = "let" ~identifierPart
  export = "export" ~identifierPart
  implements = "implements" ~identifierPart
  private = "private" ~identifierPart
  public = "public" ~identifierPart
  interface = "interface" ~identifierPart
  package = "package" ~identifierPart
  protected = "protected" ~identifierPart
  static = "static" ~identifierPart
  yield = "yield" ~identifierPart
  readonly = "readonly" ~identifierPart
  new = "new" ~identifierPart
}
